{
  "version": 3,
  "sources": ["../../src/lib/mqttServer.ts"],
  "sourcesContent": ["import type { Server as NetServer, Socket } from 'node:net';\n// eslint-disable-next-line no-duplicate-imports\nimport net from 'node:net';\n\nimport type { MqttClient, Packet } from 'mqtt-connection';\n// eslint-disable-next-line no-duplicate-imports\nimport mqttCon from 'mqtt-connection';\n\nimport type { MqttConnectEvent, MqttMessageEvent, MqttEventCallback } from './mqtt-events';\n\ntype MqttClient = typeof MqttClient;\ntype Packet = typeof Packet;\n\nexport interface MqttServerOptions {\n    port?: number;\n    host?: string;\n}\n\nexport class MqttServer /*extends EventEmitter*/ {\n    private server: NetServer;\n    private port: number;\n    private host: string;\n    //private adapter: ioBroker.Adapter;\n    private log: ioBroker.Log;\n    private mqttEventCallback: MqttEventCallback;\n\n    constructor(adapter: ioBroker.Adapter, options: MqttServerOptions = {}, callback: MqttEventCallback) {\n        //super();\n        this.log = adapter.log;\n        this.host = options.host ?? '0.0.0.0';\n        this.port = options.port ?? 1883;\n\n        this.log.silly(`[MQTT-Server] init server at ${this.host}:${this.port}`);\n        this.server = net.createServer(this.handleConnection.bind(this));\n\n        this.mqttEventCallback = callback;\n    }\n\n    private handleConnection(stream: Socket): void {\n        const remoteAddress = stream.remoteAddress || 'unknown';\n        this.log.silly(`[MQTT-Server] client connect from  ${remoteAddress}`);\n\n        const client: MqttClient = mqttCon(stream);\n        let clientId: any;\n\n        client.on('connect', async (packet: Packet) => {\n            clientId = packet.clientId;\n            this.log.silly(\n                `[MQTT-Server] (${clientId}) client connected with id ${packet.clientId} connected from ${remoteAddress}`,\n            );\n\n            // Acknowledge connection\n            client.connack({ returnCode: 0 });\n\n            // report connection\n            await this.mqttEventCallback('connect', {\n                clientId: packet.clientId,\n                ip: remoteAddress,\n                packet,\n            } as MqttConnectEvent);\n        });\n\n        client.on('publish', async (packet: Packet) => {\n            this.log.silly(\n                `[MQTT-Server] (${clientId}) received message on topic \"${packet.topic}\": ${packet.payload?.toString()}`,\n            );\n\n            if (packet.qos && packet.qos > 0) {\n                client.puback({ messageId: packet.messageId });\n            }\n\n            // report message\n            await this.mqttEventCallback('message', {\n                clientId: client.id || '',\n                ip: remoteAddress,\n                topic: packet.topic,\n                payload: packet.payload,\n                qos: packet.qos ?? 0,\n                retain: packet.retain ?? false,\n                packet,\n            } as MqttMessageEvent);\n        });\n\n        client.on('subscribe', (packet: Packet) => {\n            packet.subscriptions.forEach((sub: any) => {\n                this.log.silly(`[MQTT-Server] (${clientId}) client ${packet.clientId} subscribed to \"${sub.topic}\"`);\n            });\n            // Grant all requested QoS levels\n            client.suback({\n                granted: packet.subscriptions.map((sub: any) => sub.qos ?? 0),\n                messageId: client._lastSubscriptionId || 1,\n            });\n        });\n\n        client.on('unsubscribe', (unsubscriptions: any[]) => {\n            unsubscriptions.forEach(topic => {\n                this.log.silly(`[MQTT-Server] (${clientId}) client unsubscribed from \"${topic}\"`);\n            });\n            client.unsuback({ messageId: client._lastUnsubscribeId || 1 });\n        });\n\n        client.on('pingreq', () => {\n            this.log.silly(`[MQTT-Server] (${clientId}) client ping`);\n            client.pingresp();\n        });\n\n        client.on('disconnect', () => {\n            this.log.silly(`[MQTT-Server] (${clientId}) client disconnect from  ${remoteAddress}`);\n            client.stream.end();\n        });\n\n        client.on('close', () => {\n            this.log.silly(`[MQTT-Server] (${clientId}) client ${remoteAddress} closed connection`);\n        });\n\n        client.on('error', (err: any) => {\n            this.log.error(`[MQTT-Server] (${clientId}) client error  ${err}`);\n            client.stream.end();\n        });\n    }\n\n    public async start(): Promise<void> {\n        await new Promise<void>((resolve, reject) => {\n            this.server.listen(this.port, this.host, () => {\n                this.log.info(`MQTT server is running on ${this.host}:${this.port}`);\n                resolve();\n            });\n            this.server.on('error', err => reject(err));\n        });\n    }\n\n    public async stop(): Promise<void> {\n        await new Promise<void>((resolve, reject) => {\n            this.server.close((err?: Error) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    this.log.info('MQTT server stopped.');\n                    resolve();\n                }\n            });\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["net", "mqttCon"]
}
